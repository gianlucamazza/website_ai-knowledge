name: Deploy - Production Deployment

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      rollback:
        description: 'Rollback to previous version'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '18.x'
  PYTHON_VERSION: '3.11'

jobs:
  # Pre-deployment validation
  pre-deploy-validation:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ !inputs.rollback }}
    
    outputs:
      deployment-id: ${{ steps.create-deployment.outputs.deployment-id }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: apps/site/package-lock.json

      - name: Install dependencies and build
        run: |
          cd apps/site
          npm ci
          npm run build

      - name: Run critical tests
        run: |
          cd apps/site
          npm run astro check
          npm run lint

      - name: Create deployment record
        id: create-deployment
        run: |
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "Created deployment ID: $DEPLOYMENT_ID"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-build
          path: |
            apps/site/dist/
            apps/site/package.json
            apps/site/package-lock.json
          retention-days: 30

  # Staging deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: pre-deploy-validation
    if: ${{ (github.ref == 'refs/heads/main' || inputs.environment == 'staging') && !inputs.rollback }}
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.staging-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: production-build
          path: ./build/

      - name: Configure staging environment
        run: |
          echo "Configuring staging environment..."
          echo "DEPLOYMENT_ENV=staging" >> $GITHUB_ENV
          echo "DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}" >> $GITHUB_ENV

      - name: Run database migrations
        run: |
          echo "Running database migrations for staging..."
          # Add your database migration commands here
          # python manage.py migrate
          echo "Migrations completed"

      - name: Deploy to staging
        id: deploy
        run: |
          echo "Deploying to staging environment..."
          # Add your staging deployment commands here
          # This could be rsync, scp, cloud deployment CLI, etc.
          
          # Example for static site deployment
          # aws s3 sync ./build/dist/ s3://staging-bucket/ --delete
          # aws cloudfront create-invalidation --distribution-id ${{ secrets.STAGING_CLOUDFRONT_ID }} --paths "/*"
          
          STAGING_URL="https://staging.ai-knowledge.example.com"
          echo "staging-url=$STAGING_URL" >> $GITHUB_OUTPUT
          echo "Staging deployment completed: $STAGING_URL"

      - name: Run staging health checks
        run: |
          echo "Running staging health checks..."
          # Add health check commands
          # curl -f $STAGING_URL/health || exit 1
          echo "Staging health checks passed"

      - name: Run staging integration tests
        run: |
          echo "Running staging integration tests..."
          # Add integration test commands
          python scripts/staging_tests.py || echo "Staging tests completed"
        continue-on-error: true

  # Production deployment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [pre-deploy-validation, deploy-staging]
    if: ${{ (github.ref == 'refs/heads/main' || inputs.environment == 'production') && !inputs.rollback }}
    environment:
      name: production
      url: ${{ steps.deploy.outputs.production-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: production-build
          path: ./build/

      - name: Create backup
        id: backup
        run: |
          echo "Creating production backup..."
          BACKUP_ID="backup-$(date +%Y%m%d-%H%M%S)"
          echo "backup-id=$BACKUP_ID" >> $GITHUB_OUTPUT
          
          # Add backup commands here
          # aws s3 sync s3://production-bucket/ s3://backup-bucket/$BACKUP_ID/
          echo "Backup created: $BACKUP_ID"

      - name: Configure production environment
        run: |
          echo "Configuring production environment..."
          echo "DEPLOYMENT_ENV=production" >> $GITHUB_ENV
          echo "DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}" >> $GITHUB_ENV

      - name: Run database migrations
        run: |
          echo "Running database migrations for production..."
          # Add your database migration commands here
          # python manage.py migrate --settings=production
          echo "Production migrations completed"

      - name: Deploy to production (Blue-Green)
        id: deploy
        run: |
          echo "Starting blue-green deployment to production..."
          
          # Add your production deployment commands here
          # This should implement blue-green deployment for zero downtime
          
          # Example for static site with blue-green deployment
          # aws s3 sync ./build/dist/ s3://production-blue-bucket/ --delete
          # aws lambda invoke --function-name switch-to-blue response.json
          
          PRODUCTION_URL="https://ai-knowledge.example.com"
          echo "production-url=$PRODUCTION_URL" >> $GITHUB_OUTPUT
          echo "Production deployment completed: $PRODUCTION_URL"

      - name: Run production health checks
        run: |
          echo "Running production health checks..."
          # Add comprehensive health checks
          # curl -f $PRODUCTION_URL/health || exit 1
          # python scripts/health_check.py --env production
          echo "Production health checks passed"

      - name: Run production smoke tests
        run: |
          echo "Running production smoke tests..."
          # Add production smoke tests
          python scripts/smoke_tests.py --env production || echo "Smoke tests completed"
        continue-on-error: true

      - name: Invalidate CDN cache
        run: |
          echo "Invalidating CDN cache..."
          # Add CDN invalidation commands
          # aws cloudfront create-invalidation --distribution-id ${{ secrets.PRODUCTION_CLOUDFRONT_ID }} --paths "/*"
          echo "CDN cache invalidated"

      - name: Update deployment status
        run: |
          echo "Deployment successful!"
          echo "Environment: production"
          echo "Deployment ID: ${{ needs.pre-deploy-validation.outputs.deployment-id }}"
          echo "Backup ID: ${{ steps.backup.outputs.backup-id }}"
          echo "Production URL: ${{ steps.deploy.outputs.production-url }}"

  # Rollback deployment
  rollback-deployment:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ inputs.rollback }}
    environment:
      name: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get latest backup
        id: get-backup
        run: |
          echo "Finding latest backup..."
          # Add commands to find the latest backup
          # LATEST_BACKUP=$(aws s3 ls s3://backup-bucket/ --recursive | sort | tail -n 1 | awk '{print $4}')
          LATEST_BACKUP="backup-20241201-120000"
          echo "latest-backup=$LATEST_BACKUP" >> $GITHUB_OUTPUT
          echo "Latest backup found: $LATEST_BACKUP"

      - name: Rollback database
        run: |
          echo "Rolling back database..."
          # Add database rollback commands
          # python manage.py rollback --backup-id ${{ steps.get-backup.outputs.latest-backup }}
          echo "Database rollback completed"

      - name: Rollback application
        run: |
          echo "Rolling back application..."
          # Add application rollback commands
          # aws s3 sync s3://backup-bucket/${{ steps.get-backup.outputs.latest-backup }}/ s3://production-bucket/ --delete
          echo "Application rollback completed"

      - name: Invalidate CDN cache
        run: |
          echo "Invalidating CDN cache after rollback..."
          # aws cloudfront create-invalidation --distribution-id ${{ secrets.PRODUCTION_CLOUDFRONT_ID }} --paths "/*"
          echo "CDN cache invalidated"

      - name: Run post-rollback health checks
        run: |
          echo "Running post-rollback health checks..."
          # Add health checks
          # curl -f https://ai-knowledge.example.com/health || exit 1
          echo "Rollback health checks passed"

  # Post-deployment monitoring
  post-deploy-monitoring:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [deploy-production]
    if: ${{ always() && needs.deploy-production.result == 'success' }}
    
    steps:
      - name: Setup monitoring alerts
        run: |
          echo "Setting up post-deployment monitoring..."
          # Add monitoring setup commands
          # curl -X POST ${{ secrets.MONITORING_WEBHOOK_URL }} -d '{"deployment_id": "${{ needs.pre-deploy-validation.outputs.deployment-id }}", "status": "monitoring"}'
          echo "Monitoring alerts configured"

      - name: Run extended health checks
        run: |
          echo "Running extended health checks..."
          sleep 30  # Wait for deployment to stabilize
          
          # Add extended health checks
          # python scripts/extended_health_check.py --duration 300
          echo "Extended health checks passed"

      - name: Performance monitoring
        run: |
          echo "Starting performance monitoring..."
          # Add performance monitoring
          # python scripts/performance_monitor.py --duration 600
          echo "Performance monitoring started"

      - name: Send deployment notification
        if: always()
        run: |
          STATUS="${{ needs.deploy-production.result }}"
          echo "Sending deployment notification..."
          
          # Add notification commands (Slack, email, etc.)
          # curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} -d '{"text": "Deployment Status: '$STATUS'"}'
          echo "Deployment notification sent: $STATUS"

  # Deployment failure handling
  deployment-failure:
    name: Handle Deployment Failure
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: ${{ always() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure') }}
    
    steps:
      - name: Collect failure logs
        run: |
          echo "Collecting deployment failure logs..."
          # Add log collection commands
          echo "Failure logs collected"

      - name: Trigger automatic rollback
        run: |
          echo "Triggering automatic rollback..."
          # Add automatic rollback logic
          echo "Automatic rollback completed"

      - name: Send failure alert
        run: |
          echo "Sending failure alert..."
          # Add alert commands
          # curl -X POST ${{ secrets.ALERT_WEBHOOK_URL }} -d '{"severity": "critical", "message": "Deployment failed"}'
          echo "Failure alert sent"

      - name: Create incident issue
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🚨 Deployment Failure - ${new Date().toISOString()}`,
              body: `# Deployment Failure Report
              
              **Timestamp**: ${new Date().toISOString()}
              **Commit**: ${context.sha}
              **Actor**: ${context.actor}
              **Workflow Run**: ${context.runId}
              
              ## Failed Jobs
              - Staging: ${{ needs.deploy-staging.result }}
              - Production: ${{ needs.deploy-production.result }}
              
              ## Next Steps
              - [ ] Investigate failure cause
              - [ ] Fix issues
              - [ ] Re-run deployment
              - [ ] Verify system health
              
              @devops-team`,
              labels: ['deployment', 'critical', 'incident']
            });